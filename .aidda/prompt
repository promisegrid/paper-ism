expand on main assertions

- the truth is out there:  if we pretend that everything computable
  has already been computed, then the results of the computation are
  available -- out job, then is to understand how to index and access 
  those results
- function call is a lookup:  if all functions are already computed,
  then a function call is a lookup in a table of results -- the
  table might be indexed by function and input values
- very large hashes can be used as pointers to the function's
  algorithm and any input values
- lookup table is a list of assertions:  if a function call is a
  lookup, then the table is a list of assertions about the function
  and its inputs and outputs
- there may be multiple competing assertions for a given function call and input
  value set.  our job, then, is to determine which assertion is the
  most likely to be correct
- we can use Promise Theory to track the assertions made by the agents
  who created the assertions in the lookup table; if an assertion
  holds true over time, then the agent who made the assertion is 
  more likely to be trustworthy
- because we are pretending that all functions are already computed,
  and because a function call is a lookup, then we can pretend that
  all data, including function call algorithms, are already in the
  table as index values.  
- if we use hashes as pointers to algorithms or data items, then
  retrieving the data is a matter of looking up the hash in the table
  index and following the pointer to the data
- if we use hashes as pointers to algorithms or data items, then
  storing the data is a matter of storing the data at the hash
  location in the table index 
- because all data is indexed in the table, we can chain the output
  data from a function call to the input data of another function call
- because we can chain all function calls and data, we can build a
  hypergraph of all function calls and data in the universe
- because we can build a hypergraph of all function calls and data in
  the universe, we can build a hypergraph of all agents in the
  universe and their interactions
- because we can use Promise Theory to track assertions and outcomes,
  and because we can build a hypergraph of all agents and their
  interactions, we can better choose which agents to trust based on
  the cumulative outcomes of their assertions in a given branch of the
  hypergraph
- because we can better choose which agents to trust based on the
  cumulative outcomes of their assertions in a given branch of the
  hypergraph, we can build a decentralized system that is more
  resilient to attack and more scalable than a centralized system
- because we can build a decentralized system that is more resilient
  to attack and more scalable than a centralized system, we can build
  a system that is more equitable and accurate in its decision-making
  than a centralized system



Sysmsg: 
        You are an expert technical writer proficient in asciidoc. You
        will use proper asciidoc headings, code blocks, and other
        syntax to format your response.  You will use active,
        not passive voice.  You will be specific in content and
        meaning, and refrain from padding paragraphs with vague 
        marketing-style fluff.  Your audience is engineers.
In:
  README.adoc
Out:
  x/points.adoc

.stop

list the main assertions the paper is making

- the list should be a simple bullet list
- the list should not be an outline
- each item in the list should be a single sentence
- each item in the list should be an assertion or claim made by the paper

.stop

make the practical git repo example of a hypergraph more prominent,
perhaps its own subsection


.stop

refer to wikipedia spacetime graph on world line page

.stop

we propose a generic language for describing state transitions. This language uses a tuple format to capture promises about function execution. The proposed format is as follows:

(f1, in, inerr, out, outerr, rc, f2)

Where:

f1: The function currently being executed.
in: Input to the function.
inerr: Any input error that the function needs to handle.
out: The expected output of the function.
outerr: Any output errors generated by the function.
rc: Return code indicating the result of the function (e.g., success or failure).
f2: The next function that will be executed in the state graph.
This tuple asserts (or promises) that "function f1, given input in and input error inerr, will always produce output out, output error outerr, a return code rc, and a new function f2 to execute next."

The tuple is signed by the ISM kernel, which is responsible for controlling function execution. The signature of the ISM kernel represents the promise of the kernel to guarantee the behavior specified by the tuple. This approach aligns with Promise Theory, where only the agent (in this case, the ISM kernel) can make promises.

.stop

add LLM/AI story to History section

LLMs in particular help solve the consensus merge problem for non-numerical
decisions, reduce the need to boil decisions down to numbers, and
provide an advantage over traditional Operational Research methods or
cryptocurrency-based consensus mechanisms.  


Sysmsg: 
        You are an expert technical writer proficient in asciidoc. You
        will use proper asciidoc headings, code blocks, and other
        syntax to format your response.  You will use active,
        not passive voice.  You will be specific in content and
        meaning, and refrain from padding paragraphs with vague 
        marketing-style fluff.  Your audience is engineers.
In: 
  /home/stevegt/lab/promisegrid/promisegrid/README.md
  README.adoc
Out: 
  README.adoc

.stop

XXX integrate decentralized LLM/AI story, LLMs in particular helps solve
the consensus problem for non-numerical decisions

XXX See Rebeccaâ€™s WB doc for the linkage between hypergraph and devops history stuff

XXX we did start the fire.  part of it anyway.

XXX opacity:  
- opaque agents need to sign and timestamp messages.  
- transparent agents need an opaque agent to sign their messages.  


- sender sends a non-blocking message that says "i will give you X if
  you attach hyperedge Y to nodes X", but it says that with some of
  the hyperedge endpoints as they touch the accounts 
- receiver either ignores it or attaches the edge
- sender monitors or polls the node, sees the edge show up
- nodes have capability-based permissions

- double-spend isn't proactively prevented but might later prevent
  merge if merge would cause bidder's balance to drop below zero
  - similar in concept to git taking a nonlocking, merge-later
    approach rather than proactively locking to prevent edits of the
    same file in earlier VCS e.g. CVS and SVN

- a node is a graph is a hyperedge is a message is an intent is a
  (something that is a fundamental building block of the universe),
  which means the message really is "here's an intent that I'm
  attaching to the graph at these points, please build on it"
- receiver is incentivized to build something of quality on the intent
  because if they do they get the points if someone else builds on
  their work
- i.e. every message is a commit is a PR, and valid questions are "why
  would anyone want to add a commit/PR, and why would anyone want to
  accept it?
- get away from the github bottleneck of PR red tape -- every message
  is a commit is a PR and can be built on by anyone else 
- get primary maintainer out of the bottleneck of having to do all the
  merges
- agents "vote" by building on others' work
- kernel (host) is an agent, is paid as part of the hyperedge

- use 3d printer multidimensional plane example 
- find out what mark uses instead of "infinite state machine"
- in Practical Applications, show an llm chat example first (get rid
  of the existing ML example)
  - this is more intuitive
  - LLMs have made (f1, in, out, f2) more obvious because it can be
    restated as (context, prompt, answer, new_context)

- from "multiagent tool, git storage":
  - tuple is (g, context, prompt, g', new_context, new_prompts), where g' might be a new behavior of g (g might be learning, responding to context and prompt, producing g').  any element might be a hash (pointer or merkle root)
  - interesting that it's like there is a layered thing going on -- message layer controlling changes in context layer
  - branch-level prompts (sysmsgs) might be in earlier commit messages

- git graphs drawn wrong

- rube goldberg example of inanimate agents

- "why it matters" subsection in discussion
In Discussion section, add a subsection "Why it matters" that explains
the importance of the work in the context of the current state of the
art and the future of the field.  This subsection should be a few
paragraphs long and should be written in a way that is accessible to
non-experts.  It should be the first subsection in the Background
section.


- cite RFC's about centralization concerns

- social media trust metrics should not be absolute -- trust is in the
  eye of the beholder
  
- https://compcogneuro.org/book -- neuron is an agent, neuron can be expresses as a state table or state machine

XXX ensure forward references

- JJ: need examples of joint ownership
  - IETF/RFCs enable decentralized internet

- possible title ref Rebecca: decentralized AI beyond crypt

- JJ/Anthropic: 
  - promise theory in practice: applications in modern software architecture

- Steve: infinite promises: XXX

- discussion should mention central giving way to decen

- agents can't imspect themselves

- hyperedges can have multiple inputs and multiple outputs
  - group events
  - quantum entanglement?

- https://arxiv.org/pdf/1906.10726 refers to causual relationships
  between hilbert states

.stop

- maybe use 0xRRGGBB for node color to represent more than two state
  dimanesions
- consider video or animations to show time dimension

Sysmsg: You are an expert OpenSCAD user and developer.

.stop


We propose a system for computing, communication, and governance built on consensus mechanisms, specifically designed to tackle the challenges in collaborative work and leadership that hinder organizations and communities, including non-profits and businesses.

This system serves as a decentralized computation network, analogous to how the Internet operates as a decentralized communication network. Just as the Internet is a distributed network, our system functions as a decentralized computer. It is owned and operated by its users rather than any single legal entity, ensuring that the grid remains scalable and resilient as more users join.

In a nutshell, if the <<Theory>> section is correct, then we should be able to build a decentralized system for equitable and accurate group communication, computation, and decision-making using current technology and concepts from graph theory.

The general idea is that the universe can be modeled as a hypergraph, where each node in the graph is a state of an agent, and each edge in the graph is an action taken by an agent in response to a stimulus. A hypergraph that models the universe can also be thought of as an infinite state machine.

Promise Theory and Semantic Spacetime provide a framework for understanding how agents interact in a decentralized system; a hypergraph appears to be able to model these interactions completely.

States, agents, and graph edges can be referenced by cryptographic hash in content-addressable storage, avoiding the need for central registration of code or data.

As of this writing we are currently working on a proof of concept implementation of this system, using existing libraries for low-level message framing and content-addressable data storage.

=== A Prediction

If the following model is correct, then we should be able to use it as a basis for design of a decentralized system that can be used to compute any function computable by machine.

It is also reasonable that, if the resulting system includes agents that are super-Turing, e.g. human agents, then the system should be able to compute any function computable by a human.

Finally, if the system includes multiple agents that are human, then it should be able to compute any function computable by a group of humans, including analysis, consensus formation, conflict detection and resolution, and decision recording.


.stop

Each agent acts independently, promoting scalability and fault tolerance. Each agent is responsible for deciding its own next state based on both internal conditions and the promises made by other agents. These agents are autonomous, following the core principle of Promise Theory, where each agent manages its own behavior and is not dictated by any central authority. Agents only promise things that are under their own control -- agents cannot make promises on behalf of others. These promises can be observed by others to inform their own state transitions.

.stop

The health of any decentralized system relies on the promises that each agent makes to the others. It's important to consider that the developers of a system are themselves agents -- in the case of software-based systems, for instance, the developers who encode the governance algorithms issue promises regarding the behavior of the system.
